#!/usr/bin/env expect

log_user 0

# message_id message
array set messages_from_senders []

# message_id receiver_spawn_id
array set receivers_for_messages []

# spawn_id file_handle
array set logs_by_spawn_ids []

# spawn_id command
array set commands_by_spawn_ids []

array set option []
set option(log) ""
set option(once) ""
set option(receive) "receive (\[^\r\n]*)\r\n"
set option(send) "send (\[^\r\n:]*): (\[^\r\n]*)\r\n"
set option(prefix) ""
set option(suffix) ""

set option_re "--(\[a-z_]*)=(.*)"

set usage "Usage: command-messenger.exp \[--option=value|command] ...
Options:
    log     Filename to log to. Denote command with {}. Default empty=stdout.
    once    Set to only receive messages once. Default empty=keep receiving.
    receive Regular expression for registrations to receive messages.
            Default 'receive (\\\[^\\r\\n]*)\\r\\n'.
            Catch group required for identifier of messages to receive.
    send    Regular expression to catch messages to pass to listeners.
            Default 'send (\\\[^\\r\\n:]*): (\\\[^\\r\\n]*)\\r\\n'.
            First catch group required for recipient identifier.
            Second catch group required for collecting the message content.
    prefix  Prefix for subsequent commands. Default empty.
    suffix  Suffix for subsequent commands. Default empty.
    help    Show this usage information and exit.

This command is used to run other commands and pass messages between them.
It shows or logs all other output but hides the messages as they are passed.
For instance, you may want to pass around credentials for user accounts:

    command-messenger.exp create-account-and-output-credentials.sh \\
        record-credentials-for-access.sh
"

foreach arg $argv {
    if {[regexp -- "$option_re" "$arg" all name value]} {

        if {![info exists option($name)]} {
            send_user "Invalid option '$name'\n$usage"
            exit 2
        }

        set option($name) $value
    } elseif {[regexp -- "--?h(elp)?" $arg]} {
        send_user "$usage"
        exit 1
    } else {

        if {$option(log) > 0} {
            set log_filename $option(log)
            if {[regexp -- "(.*){}(.*)" "$option(log)" all prefix suffix]} {
                set log_filename "$prefix$arg$suffix"
            }
            if {![regexp -- ".*\.log$" "$log_filename"]} {
                set log_filename "$log_filename.log"
            }
            set file_handle [open "$log_filename" "w"]
        } else {
            set file_handle stdout
        }

        set full_command "$option(prefix)$arg$option(suffix)"
        set time [clock format [clock seconds] -format "\[%Y-%m-%d %T]"]

        puts $file_handle "$time BEGIN: $full_command"
        eval spawn "$full_command"

        array set logs_by_spawn_ids [list $spawn_id $file_handle]
        array set commands_by_spawn_ids [list $spawn_id $full_command]
    }
}

proc pass_messages {} {
    global messages_from_senders
    global receivers_for_messages
    global option

    foreach {message_id message} [array get messages_from_senders] {
        set receivers_found 0

        foreach {target_id receiver_spawn_id} [array get receivers_for_messages $message_id.*] {
            send -i $receiver_spawn_id -- "$message\n"
            incr receivers_found
        }

        if {$receivers_found > 0} {
            array unset messages_from_senders $message_id
            if {$option(once) > 0} {
                array unset receivers_for_messages $message_id
            }
        }
    }
}

while {[array size logs_by_spawn_ids] > 0} {

    expect {
        -i [array names logs_by_spawn_ids]
        -re $option(send) {
            set id $expect_out(1,string)
            set message $expect_out(2,string)
            puts $logs_by_spawn_ids($expect_out(spawn_id)) "(send $id)\n"
            array set messages_from_senders [list $id $message]
            pass_messages
            exp_continue
        }
        -re $option(receive) {
            set current_spawn_id $expect_out(spawn_id)
            set message_id $expect_out(1,string)
            puts $logs_by_spawn_ids($expect_out(spawn_id)) "(receive $message_id)"

            array set receivers_for_messages [
                list $message_id.$current_spawn_id $current_spawn_id
            ]
            pass_messages
            exp_continue
        }
        -re "(\[^\r\n]*)\[\r\n]+" {
            puts $logs_by_spawn_ids($expect_out(spawn_id)) "$expect_out(1,string)"
            exp_continue
        }
        eof {
            set spawn_id $expect_out(spawn_id)

            set time [clock format [clock seconds] -format "\[%Y-%m-%d %T]"]
            set command $commands_by_spawn_ids($spawn_id)
            set log $logs_by_spawn_ids($spawn_id)
            puts $log "$time END: $command"

            array unset logs_by_spawn_ids $spawn_id
            array unset commands_by_spawn_ids $spawn_id

            foreach {target_id receiver_spawn_id} [array get receivers_for_messages] {
                if {$receiver_spawn_id == $spawn_id} {
                    array unset receivers_for_messages $target_id
                }
            }
        }
    }

}
